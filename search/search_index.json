{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#typer-repyt","title":"typer-repyt","text":"<p>Build Typer commands dynamically</p>"},{"location":"#overview","title":"Overview","text":"<p>This Python package provides a mechanism to dynamically build Typer commands. It includes support for Options, Arguments, the Typer context, and decorators.</p> <p>Read more in Build Commands Dynamically.</p>"},{"location":"build_command/","title":"Dynamically Build Typer Commands","text":"<p>The <code>build_command</code> function of the <code>typer-repyt</code> library allows you to dynamically construct Typer commands based on a function template and a list of parameter definitions. This feature is particularly useful if you need to build out a command based on criteria that might not be completely available until run-time.</p>"},{"location":"build_command/#overview","title":"Overview","text":"<p>The <code>build_command</code> function takes a Typer app instance, a template function, and a series of parameter definitions to dynamically generate a Typer command. The template function serves as a blueprint, preserving its name and docstring, while the parameter definitions provide complete specifications for how to build the arguments and options for the command.</p>"},{"location":"build_command/#usage","title":"Usage","text":"<p>Here's an example of how to use the <code>build_command</code> feature:</p> <pre><code>from typing import Any\nfrom collections.abc import Callable\nfrom functools import wraps\n\nimport typer\nfrom typer_repyt import build_command, OptDef, ArgDef, DecDef\n\n\ndef simple_decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        print(\"Start simple decorator\")\n        result = func(*args, **kwargs)\n        print(\"End simple decorator\")\n        return result\n    return wrapper\n\n\ndef complex_decorator(a: str, k: str = \"hutt\") -&gt; Callable[..., Any]:\n    def _decorate(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            print(f\"Complex decorator args: {a=}, {k=}\")\n            print(f\"Complex decorator before function call: {args=}, {kwargs=}\")\n            result = func(*args, **kwargs)\n            print(f\"Complex decorator after function call: {result=}\")\n            return result\n        return wrapper\n    return _decorate\n\n\ncli = typer.Typer()\n\n\ndef dynamic(ctx: typer.Context, dyna1: str, dyna2: int, mite1: str, mite2: int | None):  # pyright: ignore[reportUnusedParameter]\n    \"\"\"\n    Just prints values of passed params\n    \"\"\"\n    print(f\"{dyna1=}, {dyna2=}, {mite1=}, {mite2=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna1\", param_type=str, help=\"This is dynamic option 1\", default=\"default1\"),\n    OptDef(name=\"dyna2\", param_type=int, help=\"This is dynamic option 2\"),\n    ArgDef(name=\"mite1\", param_type=str, help=\"This is mighty argument 1\"),\n    ArgDef(name=\"mite2\", param_type=int | None, help=\"This is mighty argument 2\", default=None),\n    decorators=[\n        DecDef(simple_decorator),\n        DecDef(complex_decorator, dec_args=[\"jawa\"], dec_kwargs=dict(k=\"ewok\"), is_simple=False),\n    ],\n    include_context=True,\n)\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Try running this example with the <code>--help</code> flag to see that the command is dynamically constructed :</p> <pre><code>$ python examples/dynamic.py --help\n\n Usage: dynamic.py [OPTIONS] MITE1 [MITE2]\n\n Just prints values of passed params\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    mite1      TEXT     This is mighty argument 1 [default: None] [required]               \u2502\n\u2502      mite2      [MITE2]  This is mighty argument 2 [default: None]                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --dyna2                     INTEGER  This is dynamic option 2 [default: None] [required] \u2502\n\u2502    --dyna1                     TEXT     This is dynamic option 1 [default: default1]        \u2502\n\u2502    --install-completion                 Install completion for the current shell.           \u2502\n\u2502    --show-completion                    Show completion for the current shell, to copy it   \u2502\n\u2502                                         or customize the installation.                      \u2502\n\u2502    --help                               Show this message and exit.                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The dynamically built function is equivalent to the static definition:</p> <pre><code>from collections.abc import Callable\nfrom functools import wraps\nfrom typing import Annotated, Any\n\nimport typer\n\n\ndef simple_decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        print(\"Start simple decorator\")\n        result = func(*args, **kwargs)\n        print(\"End simple decorator\")\n        return result\n    return wrapper\n\n\ndef complex_decorator(a: str, k: str = \"hutt\") -&gt; Callable[..., Any]:\n    def _decorate(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            print(f\"Complex decorator args: {a=}, {k=}\")\n            print(f\"Complex decorator before function call: {args=}, {kwargs=}\")\n            result = func(*args, **kwargs)\n            print(f\"Complex decorator after function call: {result=}\")\n            return result\n        return wrapper\n    return _decorate\n\n\ncli = typer.Typer()\n\n@cli.command()\n@simple_decorator\n@complex_decorator(\"jawa\", k=\"ewok\")\ndef static(\n    ctx: typer.Context,  # pyright: ignore[reportUnusedParameter]\n    mite1: Annotated[str, typer.Argument(help=\"This is mighty argument 1\")],\n    dyna2: Annotated[int, typer.Option(help=\"This is dynamic option 2\")],\n    dyna1: Annotated[str, typer.Option(help=\"This is dynamic option 1\")] = \"default1\",\n    mite2: Annotated[int | None, typer.Argument(help=\"This is mighty argument 2\")] = None,\n):\n    \"\"\"\n    Just prints values of passed params\n    \"\"\"\n    print(f\"{dyna1=}, {dyna2=}, {mite1=}, {mite2=}\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre>"},{"location":"build_command/#details","title":"Details","text":"<p>Let's take a closer look at how we can use the <code>build_command()</code> function.</p>"},{"location":"build_command/#function-signature","title":"Function signature","text":"<p>The function signature looks like this:</p> <pre><code>def build_command(\n    cli: typer.Typer,\n    func: Callable[..., None],\n    /,\n    *param_defs: ParamDef,\n    decorators: list[DecDef] | None = None,\n    include_context: bool | str = False,  # TODO: Think about setting this automatically if func's first arg is ctx\n</code></pre> <p>The <code>cli</code> argument is the Typer app that you want your command added to.</p> <p>The <code>func</code> argument is a \"template\" function. The <code>build_command()</code> function builds a brand new function, but it borrows some parts from the template function. Most importantly, it uses the same code body. So, any logic included in the body of the template function will appear exactly the same in the built command function. The <code>build_command()</code> function will also preserve the name of the function and it's docstring. This is important, because the function name will become the name of the command that's added to the app just like it would in a static definition of a Typer command.</p> <p>Template function parameters</p> <p>The function parameters defined in the template function will not be preserved in any way in the generated function. They are completely stripped away and replaced with the parameters you pass in <code>param_defs</code>. However, it may be useful to supply parameters to your template function that match the local values that typer will provide when it runs the command. This will ensure that type checkers won't gripe about the function. Note that the dynamic example above matches the parameters in the template function with the <code>param_defs</code> that are dynamically injected.</p> <p>The <code>param_defs</code> variadic arguments describe the <code>Option</code> and <code>Argument</code> parameters that will be injected into the constructed command function. Each of the attributes of <code>ParamDef</code>, <code>OptDef</code>, and <code>ArgDef</code> correspond directly to parameters that you can use to statically define <code>Options</code> and <code>Arguments</code> to your command.</p> <p>The <code>decorators</code> keyword argument can be used to provide decorators that should be applied to the command. This option uses the <code>DecDef</code> class to describe each decorator that will be applied.</p> <p>Finally, the <code>include_context</code> keyword argument instructs the <code>build_command</code> function whether a <code>typer.Context</code> argument should be included as the first positional argument to the constructed command. Note that in order to use a context, Typer requires that it be the first positional argument and that it is named \"ctx\".</p>"},{"location":"build_command/#paramdef","title":"<code>ParamDef</code>","text":"<p><code>ParamDef</code> is a base class that contains parameters that are shared by both <code>Option</code> and <code>Argument</code> command parameters.</p> <p>Here is the signature of <code>ParamDef</code>:</p> <pre><code>@dataclass\nclass ParamDef:\n    \"\"\"\n    Define the necessary components to build a Typer `Option` or `Argument`.\n\n    These elements are used by both `OptDef` and `ArgDef`.\n    \"\"\"\n\n    name: str\n    param_type: UnionType | type[Any]\n    default: Any | None | Literal[Sentinel.NOT_GIVEN] = Sentinel.NOT_GIVEN\n    help: str | None = None\n    rich_help_panel: str | None = None\n    show_default: bool | str = True\n</code></pre> <p>Let's dig into what each attribute is used for.</p>"},{"location":"build_command/#name","title":"<code>name</code>","text":"<p>This will be the name of the parameter.</p> <p>In this example, the two commands <code>static</code> and <code>dynamic</code> are equivalent: <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[str, Option()]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: str):\n    print(f\"{dyna=}\")\n\n\nbuild_command(cli, dynamic, OptDef(name=\"dyna\", param_type=str))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre></p> <p>Notice that the first parameter to <code>static</code> is <code>dyna</code>. When we build the command dynamically, the <code>name</code> attribute we pass to <code>OptDef</code> becomse the name of the option.</p> <p>The help text from both commands is identical:</p> <pre><code>$ python examples/param_def/name.py static --help\n\n Usage: name.py static [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --dyna        TEXT  [default: None] [required]                                           \u2502\n\u2502    --help              Show this message and exit.                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n$ python examples/param_def/name.py dynamic --help\n\n Usage: name.py dynamic [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --dyna        TEXT  [default: None] [required]                                           \u2502\n\u2502    --help              Show this message and exit.                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"build_command/#param_type","title":"<code>param_type</code>","text":"<p>This is the type hint for the parameter that Typer will use to cast the command input to the appropriate type. It will also validate the input with this type so that providing \"thirteen\", for example, to an <code>int</code> typed parameter will raise an error.</p> <p>Again, in this example, the two commands <code>static</code> and <code>dynamic</code> are equivalent:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[int | None, Option()]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: int | None):\n    print(f\"{dyna=}\")\n\n\nbuild_command(cli, dynamic, OptDef(name=\"dyna\", param_type=int | None))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>The <code>param_type</code> can be any of the types supported by Typer. In this case, we are actually using a <code>UnionType</code> expressed as <code>int | None</code> to indicate that the parameter value will either be an integer or <code>None</code>.</p> <p>Only basic unions</p> <p>Typer does not currently support any <code>UnionType</code>. Instead, it can only use a <code>UnionType</code> that is composed of composed of two types: one <code>NoneType</code> and any other type that is not <code>NoneType</code>. See this issue on GitHub for more details.</p> <p>Further reading</p> <ul> <li>Typer: CLI Parameter Types</li> </ul> <p>not</p>"},{"location":"build_command/#default","title":"<code>default</code>","text":"<p>This describes the default value that will be assigned to the parameter. The <code>default</code> parmeter may be any Typer supported type or <code>None</code>.</p> <p>Here is another example with equivalent <code>static</code> and <code>dynamic</code> commands:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[int | None, Option()]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: int | None):\n    print(f\"{dyna=}\")\n\n\nbuild_command(cli, dynamic, OptDef(name=\"dyna\", param_type=int | None))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>You may be wondering about the <code>Sentinel</code> type that <code>default</code> can use. Sentinels are a bit of an advanced concept, but in the plainest terms it lets <code>build_command</code> tell the difference between <code>None</code> being explicitly passed as the default value and no default parameter being supplied. You can read more about Sentinel values in PEP 661.</p> <p>Further reading</p> <ul> <li>Typer: Required CLI Options</li> <li>Typer: CLI Arguments with Default</li> <li>PEP 661: Sentinel Types</li> </ul>"},{"location":"build_command/#help","title":"<code>help</code>","text":"<p>This argument provides the text that will describe the parameter's purpose when you run the command with the <code>--help</code> flag. If it is not provided, Typer won't show any description of the parameter.</p> <p>Here is yet another example with equivalent commands:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[str, Option(help=\"Dyna goes BOOM\")]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: str):\n    print(f\"{dyna=}\")\n\n\nbuild_command(cli, dynamic, OptDef(name=\"dyna\", param_type=str, help=\"Dyna goes BOOM\"))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Here is what the produced <code>--help</code> output looks like:</p> <pre><code>$ python examples/param_def/help.py dynamic --help\n\n Usage: help.py dynamic [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --dyna        TEXT  Dyna goes BOOM [default: None] [required]                             \u2502\n\u2502    --help              Show this message and exit.                                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Further reading</p> <ul> <li>Typer: CLI Options with Help</li> <li>Typer: CLI Arguments with Help</li> </ul>"},{"location":"build_command/#rich_help_panel","title":"<code>rich_help_panel</code>","text":"<p>Typer allows you to add more eye candy in the <code>--help</code> output by putting parameters inside of Rich panels. This doesn't add any functionality at all, it just changes the appearance of the <code>--help</code> output.</p> <p>Can you believe it, another example of equivalent commands?</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[str, Option(rich_help_panel=\"Dyna goes BOOM\")]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: str):\n    print(f\"{dyna=}\")\n\n\nbuild_command(cli, dynamic, OptDef(name=\"dyna\", param_type=str, rich_help_panel=\"Dyna goes BOOM\"))\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>You can see how the <code>--dyna</code> option is now wrapped in a fancy Rich panel in the <code>--help</code> output:</p> <pre><code>$ python examples/param_def/rich_help_panel.py dynamic --help\n\n Usage: rich_help_panel.py dynamic [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Dyna goes BOOM \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --dyna        TEXT  [default: None] [required]                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Further reading</p> <ul> <li>Typer: CLI Options with Help -- Help with style using Rich</li> <li>Typer: CLI Arguments with Help -- Help with style using Rich</li> <li>Rich: Panel</li> </ul>"},{"location":"build_command/#show_default","title":"<code>show_default</code>","text":"<p>This parameter controls whether the default value for a parameter is shown in the <code>--help</code> text. If it is set to <code>False</code>, no help will be shown as if the <code>help</code> parameter was not supplied. If it is set to a string value, then the default value is replaced with the supplied string (I'm not sure where this would be useful!).</p> <p>Let's look at the equivalent commands:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(\n    dyna1: Annotated[str, Option(show_default=False)] = \"BOOM\",\n    dyna2: Annotated[str, Option(show_default=\"-hidden-\")] = \"BOOM\",\n):\n    print(f\"{dyna1=}, {dyna2=}\")\n\n\ndef dynamic(dyna1: str, dyna2: str):\n    print(f\"{dyna1=}, {dyna2=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna1\", param_type=str, default=\"BOOM\", show_default=False),\n    OptDef(name=\"dyna2\", param_type=str, default=\"BOOM\", show_default=\"-hidden-\"),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>And, here is the <code>--help</code> output it produces:</p> <pre><code>$ python examples/param_def/show_default.py dynamic --help\n\n Usage: show_default.py dynamic [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --dyna1        TEXT                                                                          \u2502\n\u2502 --dyna2        TEXT  [default: (-hidden-)]                                                   \u2502\n\u2502 --help               Show this message and exit.                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Further reading</p> <ul> <li>Typer: CLI Options with Help -- Hide default from help</li> <li>Typer: CLI Options with Help -- Custom default string</li> <li>Typer: CLI Arguments with Help -- Help with defaults</li> <li>Typer: CLI Arguments with Help -- Custom default string</li> </ul>"},{"location":"build_command/#metavar","title":"<code>metavar</code>","text":"<p>You may want to use some special text to be a placeholder in the <code>--help</code> text that describes the parameter. These are called \"Meta Variables\". For arguments, they show the type and where the argument should needs to be provided in the command. For options, the <code>metavar</code> describes the type.</p> <p>Have a look at the equivalent implementations in this example:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Argument\nfrom typer_repyt import build_command, ArgDef\n\ncli = Typer()\n\n\n@cli.command()\ndef static(mite: Annotated[str, Argument(metavar=\"NITRO\")]):\n    print(f\"{mite=}\")\n\n\ndef dynamic(mite: str):\n    print(f\"{mite=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    ArgDef(name=\"mite\", param_type=str, metavar=\"NITRO\"),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>To see where the <code>metavar</code> comes in, check out the <code>--help</code> output:</p> <pre><code>$ python examples/arg_def/metavar.py dynamic --help\n\n Usage: metavar.py dynamic [OPTIONS] NITRO\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    mite      NITRO  [default: None] [required]                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You an see that it's used as a placeholder in the \"Usage\" string and again in the argument description.</p> <p>Further reading</p> <ul> <li>Typer: CLI Arguments with Help -- Custom help name (metavar)</li> </ul>"},{"location":"build_command/#optdef","title":"<code>OptDef</code>","text":"<p><code>OptDef</code> is a the derived class that contains all the remaining parameters that can be passed to a Typer <code>Option</code> parameter.</p> <p>Here is the signature of <code>OptDef</code>:</p> <pre><code>@dataclass\nclass OptDef(ParamDef):\n    \"\"\"\n    Define the additional components to build a Typer `Option`.\n    \"\"\"\n\n    prompt: bool | str = False\n    confirmation_prompt: bool = False\n    hide_input: bool = False\n    override_name: str | None = None\n    short_name: str | None = None\n</code></pre> <p>Let's explore how each of these attributes work.</p>"},{"location":"build_command/#prompt","title":"<code>prompt</code>","text":"<p>Typer allows you to prompt the user for input when you run a command. This is accomplished with the <code>prompt</code> parameter. The value of this parameter can have two different types. If the type is <code>bool</code>, then Typer will just use the <code>name</code> of the parameter as the prompt. If the type is <code>str</code>, then the provided string will be used as the prompt.</p> <p>Here are the equivalent commands:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(\n    dyna1: Annotated[str, Option(prompt=True)],\n    dyna2: Annotated[str, Option(prompt=\"Dyna2 goes\")] = \"POW\",\n):\n    print(f\"{dyna1=}, {dyna2=}\")\n\n\ndef dynamic(dyna1: str, dyna2: str):\n    print(f\"{dyna1=}, {dyna2=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna1\", param_type=str, prompt=True),\n    OptDef(name=\"dyna2\", param_type=str, prompt=\"Dyna2 goes\", default=\"POW\"),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>When we run the command, we are prompted to provide the values:</p> <pre><code>$ python examples/opt_def/prompt.py dynamic\nDyna1: BOOM\nDyna2 goes [POW]:\ndyna1='BOOM', dyna2='POW'\n</code></pre> <p>Notice that since we provided a <code>default</code> value for <code>dyna2</code>, it is shown in the prompt and then used if the user doesn't enter their own value.</p> <p>Further reading</p> <ul> <li>Typer: CLI Option Prompt</li> </ul>"},{"location":"build_command/#confirmation_prompt","title":"<code>confirmation_prompt</code>","text":"<p>Sometimes, you want to make sure that the text that the user provided the first time is correct by asking them to enter the same entry again. To accomplish this, we can use a <code>confirmation_prompt</code>. After entering the first prompted value, the user will be prompted to enter it again. Only if the values match will the prompt input be accepted. If it does not match, the user will be asked to complete the prompt (and confirmation) over again.</p> <p>Again, we have equivalent implementations:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[str, Option(prompt=True, confirmation_prompt=True)]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: str):\n    print(f\"{dyna=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna\", param_type=str, prompt=True, confirmation_prompt=True),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Running the example produces input like this:</p> <pre><code>$ python examples/opt_def/confirmation_prompt.py dynamic\nDyna: BOOM\nRepeat for confirmation: BOOM\ndyna='BOOM'\n\n\n$ python examples/opt_def/confirmation_prompt.py dynamic\nDyna: BOOM\nRepeat for confirmation: POW\nError: The two entered values do not match.\nDyna:\n</code></pre> <p>Further reading</p> <ul> <li>Typer: Password CLI Option and Confirmation Prompt</li> </ul>"},{"location":"build_command/#hide_input","title":"<code>hide_input</code>","text":"<p>The <code>confirmation_prompt</code> parameter is most useful when you use it with the <code>hide_input</code> parameter. Such a combination can be used to request a password from a user and confirm their entry all while hiding what they are typing. This is a very familiar pattern on web apps and other CLIs, so it's very nice that it's available in Typer as well.</p> <p>Here are our equivalent implementations:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[str, Option(prompt=True, confirmation_prompt=True, hide_input=True)]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: str):\n    print(f\"{dyna=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna\", param_type=str, prompt=True, confirmation_prompt=True, hide_input=True),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>When we run the example, the input provided to the prompt is completely invisible:</p> <pre><code>$ python examples/opt_def/hide_input.py dynamic\nDyna:\nRepeat for confirmation:\ndyna='BOOM'\n</code></pre> <p>Further reading</p> <ul> <li>Typer: Password CLI Option and Confirmation Prompt -- A Password prompt</li> </ul>"},{"location":"build_command/#override_name","title":"<code>override_name</code>","text":"<p>Typer also provides a mechanism to override the name of the option. There are many situations in which this is helpful, but it's probably most helpful when you want the <code>Option</code> parameter to use a Python keyword that you can't use as a parameter name.</p> <p>Consider these equivalent commands:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(class_name: Annotated[str, Option(\"--class\")]):\n    print(f\"class={class_name}\")\n\n\ndef dynamic(class_name: str):\n    print(f\"class={class_name}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"class_name\", param_type=str, override_name=\"class\"),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Here is the help that this produces:</p> <pre><code>$ python examples/opt_def/override_name.py dynamic --help\n\n Usage: override_name.py dynamic [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --class        TEXT  [default: None] [required]                                           \u2502\n\u2502    --help               Show this message and exit.                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Notice how using the <code>override_name</code> parameter allows us to have a <code>--class</code> option in our command even though the keyword <code>class</code> cannot be used as a parameter name in python.</p> <p>It's also worth pointing out that unlike the Typer native way of providing an alternative name for the option's long form, the <code>override_name</code> parameter does not require you to include the leading dashes as in <code>--class</code>.</p> <p>Further reading</p> <ul> <li>Typer: CLI Option Name</li> </ul>"},{"location":"build_command/#short_name","title":"<code>short_name</code>","text":"<p>We can also provide a short name for the <code>Option</code> using the <code>short_name</code> parameter. Like the <code>override_name</code> parameter, you don't need to provide the leading dash (as Typer requires).</p> <p>Here we have the equivalent commands:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n@cli.command()\ndef static(dyna: Annotated[str, Option(\"-d\")]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: str):\n    print(f\"{dyna=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna\", param_type=str, short_name=\"d\"),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>And this produces some friendly help including the option's short form:</p> <pre><code>$ python examples/opt_def/short_name.py dynamic --help\n\n Usage: short_name.py dynamic [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *          -d      TEXT  [default: None] [required]                                          \u2502\n\u2502    --help                Show this message and exit.                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Notice here that if you include <code>short_name</code> without an accompanying <code>override_name</code>, then the command will <code>only</code> use the short-form. This matches Typer's functionality where if you provide only a shot-form option, the long-form option will not be used.</p> <p>Further reading</p> <ul> <li>Typer: CLI Option Name -- CLI option short names</li> </ul>"},{"location":"build_command/#callback","title":"<code>callback</code>","text":"<p>One of the more interesting abilities of Typer <code>Option</code> pareameters is the ability to register a callback. A callback is a function that:</p> <ul> <li>is called with the value of the parameter that was provided on the command-line</li> <li>operates on it</li> <li>returns a value that will replace the value it was called with</li> </ul> <p>Let's look at an example:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n\ndef back(dyna: str):\n    print(f\"Callback operating on {dyna=}\")\n    return dyna * 3\n\n\n@cli.command()\ndef static(dyna: Annotated[str, Option(callback=back)]):\n    print(f\"{dyna=}\")\n\n\ndef dynamic(dyna: str):\n    print(f\"{dyna=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna\", param_type=str, callback=back),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Now, let's see what happens when we run this command:</p> <pre><code>$ python examples/opt_def/callback.py dynamic --dyna=BOOM\nCallback operating on dyna='BOOM'\ndyna='BOOMBOOMBOOM'\n</code></pre> <p>Here, you can see how the callback mutated the value of <code>dyna</code>.</p> <p>Callback functions are often used for validating the parameter. In those cases, the <code>callback</code> would raise an exception if the value didn't match some needed criteria. However, you can do anything you like with the value passed to a callback.</p> <p>Further reading</p> <ul> <li>Typer: CLI Option Callback and Context</li> </ul>"},{"location":"build_command/#is_eager","title":"<code>is_eager</code>","text":"<p>The <code>is_eager</code> parameter simply makes a <code>callback</code> attached to an <code>Option</code> evaluate before other, non-eager callbacks. The use-cases for eager callbacks aren't obvious, but you may find the need for it at some point.</p> <p>Here is the equivalent example for <code>is_eager</code>:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Option\nfrom typer_repyt import build_command, OptDef\n\ncli = Typer()\n\n\ndef back1(val: str):\n    print(f\"Callback 1 operating on {val=}\")\n    return f\"one: {val}\"\n\ndef back2(val: str):\n    print(f\"Callback 2 operating on {val=}\")\n    return f\"two: {val}\"\n\n\n@cli.command()\ndef static(\n    dyna1: Annotated[str, Option(callback=back1)],\n    dyna2: Annotated[str, Option(callback=back2, is_eager=True)],\n):\n    print(f\"{dyna1=}, {dyna2=}\")\n\n\ndef dynamic(dyna1: str, dyna2: str):\n    print(f\"{dyna1=}, {dyna2=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna1\", param_type=str, callback=back1),\n    OptDef(name=\"dyna2\", param_type=str, callback=back2, is_eager=True),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>And, running the command produces this:</p> <pre><code>$ python examples/opt_def/is_eager.py dynamic --dyna1=BOOM --dyna2=POW\nCallback 2 operating on val='POW'\nCallback 1 operating on val='BOOM'\ndyna1='one: BOOM', dyna2='two: POW'\n</code></pre> <p>Here we see that indeed <code>back2()</code> that was designated with <code>is_eager</code> was called first.</p> <p>Further reading</p> <ul> <li>Typer: Version CLI Option, <code>is_eager</code></li> </ul>"},{"location":"build_command/#argdef","title":"<code>ArgDef</code>","text":"<p>Like <code>OptDef</code>, <code>ArgDef</code> is derived from the <code>ParamDef</code> class. It contains additional parameters that can only be passed to a Typer <code>Argument</code> parameter.</p> <p>Here is the signature of <code>ArgDef</code>:</p> <pre><code>@dataclass\nclass ArgDef(ParamDef):\n    \"\"\"\n    Define the additional components to build a Typer `Argument`.\n    \"\"\"\n\n    hidden: bool = False\n    envvar: str | list[str] | None = None\n</code></pre> <p>Here are what each of the attributes do.</p>"},{"location":"build_command/#hidden","title":"<code>hidden</code>","text":"<p>Sometimes, the purpose of an <code>Argument</code> is so obvious that it's just redundant to include help text for it. In such a case, you can hide the help text using the <code>hidden</code> parameter.</p> <p>Observe the example:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Argument\nfrom typer_repyt import build_command, ArgDef\n\ncli = Typer()\n\n\n@cli.command()\ndef static(mite: Annotated[str, Argument(hidden=True)]):\n    print(f\"{mite=}\")\n\n\ndef dynamic(mite: str):\n    print(f\"{mite=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    ArgDef(name=\"mite\", param_type=str, hidden=True),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Here you can see how the <code>Argument</code> does not have a dedicated help section:</p> <pre><code>$ python examples/arg_def/hidden.py dynamic --help\n\n Usage: hidden.py dynamic [OPTIONS] MITE\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Further reading</p> <ul> <li>Typer: CLI Arguments with Help -- Hide a CLI argument from the help text</li> </ul>"},{"location":"build_command/#envvar","title":"<code>envvar</code>","text":"<p>One very cool feature of Typer is the ability to use an environment variable to provide the value for an <code>Argument</code> if one is not provided by the user. Enter the <code>envvar</code> parameter. This acts as a default for the argument if no value is provided by the user and if the enviornment variable is set.</p> <p>Additionally, it's possible to provide more than one environment variable that can be used to set the value of the <code>Argument</code>. If more than one is provided, then the <code>Argument</code> value will be set by the first environment variable in the list that is defined.</p> <p>Let's see it in action in an example:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Argument\nfrom typer_repyt import build_command, ArgDef\n\ncli = Typer()\n\n\n@cli.command()\ndef static(\n    mite1: Annotated[str, Argument(envvar=\"MITE\")],\n    mite2: Annotated[str, Argument(envvar=[\"NITRO\", \"DYNA\", \"MITE\"])],\n):\n    print(f\"{mite1=}, {mite2=}\")\n\n\ndef dynamic(mite1: str, mite2: str):\n    print(f\"{mite1=}, {mite2=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    ArgDef(name=\"mite1\", param_type=str, envvar=\"MITE\"),\n    ArgDef(name=\"mite2\", param_type=str, envvar=[\"NITRO\", \"DYNA\", \"MITE\"]),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>First, let's have a look at what the <code>--help</code> text looks like for this command:</p> <pre><code>$ python examples/arg_def/envvar.py dynamic --help\n\n Usage: envvar.py dynamic [OPTIONS] MITE1 MITE2\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    mite1      TEXT  [env var: MITE] [default: None] [required]                             \u2502\n\u2502 *    mite2      TEXT  [env var: NITRO, DYNA, MITE] [default: None] [required]                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The environment variables that will be used for the argument are displayed in the help text! Very nice.</p> <p>Now, let's set some environment variables and run the command:</p> <pre><code>MITE=BOOM DYNA=POW python examples/arg_def/envvar.py dynamic\nmite1='BOOM', mite2='POW'\n</code></pre> <p>You can see that for the second <code>Argument</code>, it got the value of the first defined environment variable in its list, which was the value bound to \"DYNA\".</p> <p>Further reading</p> <ul> <li>Typer: CLI Arguments with Environment Variables</li> </ul>"},{"location":"build_command/#show_envvar","title":"<code>show_envvar</code>","text":"<p>You may not want to reflect the environment variables used by an <code>Argument</code> in the help text. If that's the case, just set the <code>show_envvar</code> parameter to <code>False</code>.</p> <p>Here we have our equivalent implementations:</p> <pre><code>from typing import Annotated\n\nfrom typer import Typer, Argument\nfrom typer_repyt import build_command, ArgDef\n\ncli = Typer()\n\n\n@cli.command()\ndef static(mite: Annotated[str, Argument(envvar=\"MITE\", show_envvar=False)]):\n    print(f\"{mite=}\")\n\n\ndef dynamic(mite: str):\n    print(f\"{mite=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    ArgDef(name=\"mite\", param_type=str, envvar=\"MITE\", show_envvar=False),\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>This results in the environment variables not being shown in the <code>--help</code> text:</p> <pre><code>$ python examples/arg_def/show_envvar.py dynamic --help\n\n Usage: show_envvar.py dynamic [OPTIONS] MITE\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    mite      TEXT  [default: None] [required]                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Further reading</p> <ul> <li>Typer: CLI Arguments with Environment Variables -- Hide an env var from the help text</li> </ul>"},{"location":"build_command/#decdef","title":"<code>DecDef</code>","text":"<p>The <code>DecDef</code> class is used to define a decorator that should be added to the final built command. This allows you to use any of the available decorators that need to be applied to the dynamically constructed function but were not applied to the original \"template\" funciton.</p> <p>Here is the signature of <code>DecDef</code>:</p> <pre><code>@dataclass\nclass DecDef:\n    \"\"\"\n    Define a decorator function and it parameters.\n    \"\"\"\n\n    dec_func: Callable[..., Any]\n    dec_args: list[Any] = field(default_factory=list)\n    dec_kwargs: dict[str, Any] = field(default_factory=dict)\n    is_simple: bool = True\n\n    def decorate(self, f: Callable[..., Any]) -&gt; Callable[..., Any]:\n        BuildCommandError.require_condition(\n            not self.is_simple or (self.dec_args == [] and self.dec_kwargs == {}),\n            \"Decorator arguments are not allowed for simple decorators\",\n        )\n\n        def wrap(*args: Any, **kwargs: Any) -&gt; Any:\n            if self.is_simple:\n                return self.dec_func(f)(*args, **kwargs)\n            else:\n                return self.dec_func(*self.dec_args, **self.dec_kwargs)(f)(*args, **kwargs)\n\n        update_wrapper(wrap, f)\n</code></pre> <p>About <code>decorate()</code></p> <p>The <code>decorate()</code> function is used by the <code>build_command()</code> function to apply the decorator. It wasn't intentded to be used directly, but it may work for other purposes. No gurantees are provided!</p> <p>Here are what each of the attributes do.</p>"},{"location":"build_command/#dec_func","title":"<code>dec_func</code>","text":"<p>This is the decorator function that should be applied to the dynamically constructed command.</p> <p>Have a look at the equivalent implementations in this example:</p> <pre><code>from typing import Any\nfrom collections.abc import Callable\nfrom functools import wraps\n\nfrom typer import Typer\nfrom typer_repyt import build_command, DecDef\n\ndef simple_decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        print(\"Start simple decorator\")\n        result = func(*args, **kwargs)\n        print(\"End simple decorator\")\n        return result\n    return wrapper\n\ncli = Typer()\n\n@cli.command()\n@simple_decorator\ndef static():\n    print(\"In command\")\n\n\ndef dynamic():\n    print(\"In command\")\n\nbuild_command(\n    cli,\n    dynamic,\n    decorators=[DecDef(dec_func=simple_decorator)],\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Let's run both the static and dynamic command from the example and see that the decorator is applied as expected:</p> <pre><code>$ python examples/dec_def/dec_func.py static\nStart simple decorator\nIn command\nEnd simple decorator\n\n$ python examples/dec_def/dec_func.py dynamic\nStart simple decorator\nIn command\nEnd simple decorator\n</code></pre>"},{"location":"build_command/#dec_args","title":"<code>dec_args</code>","text":"<p>The <code>dec_args</code> keyword argument provides a list of positional arguments that should be provided to the decorator.</p> <p>Complex decorators only!</p> <p>The <code>dec_args</code> keyword argument can only be used with a \"complex\" decorator.</p> <p>A \"simple\" decorator is provided without parentheses or any arguments.</p> <p>A \"complex\" decorator is provided with parentheses and may recieve positional and keyword arguments.</p> <p>Here are two equivalent implementations with positional arguments:</p> <pre><code>from collections.abc import Callable\nfrom functools import wraps\nfrom typing import Any\n\nimport typer\n\nfrom typer_repyt import build_command, DecDef\n\n\ndef complex_decorator(a: str, b: int) -&gt; Callable[..., Any]:\n    def _decorate(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            print(f\"Complex decorator args: {a=}, {b=}\")\n            print(\"Complex decorator before function call\")\n            result = func(*args, **kwargs)\n            print(\"Complex decorator after function call\")\n            return result\n        return wrapper\n    return _decorate\n\n\ncli = typer.Typer()\n\n\n@cli.command()\n@complex_decorator(\"jawa\", 13)\ndef static():\n    print(\"In command\")\n\n\ndef dynamic():\n    print(\"In command\")\n\nbuild_command(\n    cli,\n    dynamic,\n    decorators=[DecDef(dec_func=complex_decorator, dec_args=[\"jawa\", 13], is_simple=False)],\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Let's check to make sure that the static and dynamic commands produce the same output:</p> <pre><code>$ python examples/dec_def/dec_args.py static\nComplex decorator args: a='jawa', b=13\nComplex decorator before function call\nIn command\nComplex decorator after function call\n\n$ uv run python examples/dec_def/dec_args.py dynamic\nComplex decorator args: a='jawa', b=13\nComplex decorator before function call\nIn command\nComplex decorator after function call\n</code></pre>"},{"location":"build_command/#dec_kwargs","title":"<code>dec_kwargs</code>","text":"<p>The <code>dec_kwargs</code> keyword argument provides a dictionary of keyword arguments that should be provided to the decorator.</p> <p>Complex decorators only!</p> <p>The <code>dec_kwargs</code> keyword argument can only be used with a \"complex\" decorator.</p> <p>Once again, we have equivalent implementations in an example:</p> <pre><code>from collections.abc import Callable\nfrom functools import wraps\nfrom typing import Any\n\nimport typer\n\nfrom typer_repyt import build_command, DecDef\n\n\ndef complex_decorator(a: str = \"jawa\", b: int = 13) -&gt; Callable[..., Any]:\n    def _decorate(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            print(f\"Complex decorator keyword args: {a=}, {b=}\")\n            print(\"Complex decorator before function call\")\n            result = func(*args, **kwargs)\n            print(\"Complex decorator after function call\")\n            return result\n        return wrapper\n    return _decorate\n\n\ncli = typer.Typer()\n\n\n@cli.command()\n@complex_decorator(a=\"ewok\", b=21)\ndef static():\n    print(\"In command\")\n\n\ndef dynamic():\n    print(\"In command\")\n\nbuild_command(\n    cli,\n    dynamic,\n    decorators=[DecDef(dec_func=complex_decorator, dec_kwargs=dict(a=\"ewok\", b=21), is_simple=False)],\n)\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <p>Let's check to make sure that the static and dynamic commands produce the same output:</p> <pre><code>$ python examples/dec_def/dec_kwargs.py static\nComplex decorator kewyord args: a='ewok', b=21\nComplex decorator before function call\nIn command\nComplex decorator after function call\n\n$ python examples/dec_def/dec_kwargs.py dynamic\nComplex decorator kewyord args: a='ewok', b=21\nComplex decorator before function call\nIn command\nComplex decorator after function call\n</code></pre>"},{"location":"build_command/#is_simple","title":"<code>is_simple</code>","text":"<p>The <code>is_simple</code> keyword argument is a flag that indicates whether the provided decorator is \"simple\" or \"complex\". Basically, if the decorator is used without parentheses it is a \"simple\" decorator. If the decorator must include parentheses and possibly takes positional and keyword arguments, then it is \"complex\".</p> <p>Not official</p> <p>The adjectives \"simple\" and \"complex\" are not used in official Python documentation. However, it's useful in the context of the <code>typer-repyt</code> package to clearly explain the difference.</p> <p>See previous examples to see how <code>is_simple</code> can be applied for decorators.</p>"},{"location":"demo/","title":"Demo","text":"<p>The <code>typer-repyt</code> package includes an \"extra\" that can be installed to show all its features. Each demo focuses on a particular feature and runs a few examples that demonstrate how the feature can be used in your CLI app.</p>"},{"location":"demo/#installation","title":"Installation","text":"<p>To install the <code>demo</code> with <code>typer-repyt</code> you need to supply it as an \"extra\" when installing <code>typer-repyt</code>. The following command can be used:</p> <pre><code>pip install typer-repyt[demo]\n</code></pre>"},{"location":"demo/#running-the-demo","title":"Running the demo","text":"<p>An entrypoint for the demo is included when it is installed. Simply run:</p> <pre><code>typer-repyt-demo\n</code></pre> <p>If you provide no arguments, it will run all available demos. If you wish to only see the demos for a particular feature, you can use the <code>--feature=&lt;feature&gt;</code> option to target one feature.</p> <p>To see all available options, run:</p> <pre><code>typer-repyt-demo --help\n</code></pre>"},{"location":"demo/#running-the-demo-in-an-isolated-environment-with-uv","title":"Running the demo in an isolated environment with uv","text":"<p>If you want to run the demo but not include its dependencies in your system python or an activated virtual environment, you can execute the demo with uv:</p> <pre><code>uvx --from=typer-repyt[demo] typer-repyt-demo\n</code></pre>"},{"location":"demo/#check-out-the-source","title":"Check out the source","text":"<p>You can also examine the demo source to examine how <code>typer-repyt</code> is used.</p> <p>Check out the source code on Github.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 to 3.13</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#install-from-pypi","title":"Install from pypi:","text":"<p>This will install the latest release from pypi via pip:</p> <pre><code>pip install typer-repyt\n</code></pre> <p>To include the runnable demo, you need to include the <code>demo</code> extra:</p> <pre><code>pip install typer-repyt[demo]\n</code></pre>"},{"location":"reference/","title":"typer-repyt Reference","text":""},{"location":"reference/#typer_repyt.build_command","title":"typer_repyt.build_command","text":"<p>Classes:</p> Name Description <code>ArgDef</code> <p>Define the additional components to build a Typer <code>Argument</code>.</p> <code>DecDef</code> <p>Define a decorator function and it parameters.</p> <code>OptDef</code> <p>Define the additional components to build a Typer <code>Option</code>.</p> <code>ParamDef</code> <p>Define the necessary components to build a Typer <code>Option</code> or <code>Argument</code>.</p> <p>Functions:</p> Name Description <code>build_command</code> <p>Build a Typer command dynamically based on a function template and list of argument definitions.</p>"},{"location":"reference/#typer_repyt.build_command.ArgDef","title":"ArgDef  <code>dataclass</code>","text":"<p>               Bases: <code>ParamDef</code></p> <p>Define the additional components to build a Typer <code>Argument</code>.</p>"},{"location":"reference/#typer_repyt.build_command.DecDef","title":"DecDef  <code>dataclass</code>","text":"<p>Define a decorator function and it parameters.</p>"},{"location":"reference/#typer_repyt.build_command.OptDef","title":"OptDef  <code>dataclass</code>","text":"<p>               Bases: <code>ParamDef</code></p> <p>Define the additional components to build a Typer <code>Option</code>.</p>"},{"location":"reference/#typer_repyt.build_command.ParamDef","title":"ParamDef  <code>dataclass</code>","text":"<p>Define the necessary components to build a Typer <code>Option</code> or <code>Argument</code>.</p> <p>These elements are used by both <code>OptDef</code> and <code>ArgDef</code>.</p>"},{"location":"reference/#typer_repyt.build_command.build_command","title":"build_command","text":"<pre><code>build_command(\n    cli: Typer,\n    func: Callable[..., None],\n    /,\n    *param_defs: ParamDef,\n    decorators: list[DecDef] | None = None,\n    include_context: bool | str = False,\n)\n</code></pre> <p>Build a Typer command dynamically based on a function template and list of argument definitions.</p> <p>Parameters:</p> Name Type Description Default <code>cli</code> <code>Typer</code> <p>The Typer app that the command should be added to</p> required <code>func</code> <code>Callable[..., None]</code> <p>A \"template\" function that will be used to build out the final function.              The name of the function will be preserved as will its docstring.              Though it is useful to define arguments for the function that match the opt_defs, it is not necessary.              It will, however, help with static type checking.</p> required <code>param_defs</code> <code>ParamDef</code> <p>Argument definitions that will be used to dynamically build the Typer command.</p> <code>()</code> <code>decorators</code> <code>list[DecDef] | None</code> <p>An optional list of decorators to apply to the command function. Like regular decorators, they are              applied in reverse order with those nearest to the function definition being called first.</p> <code>None</code> <code>include_context</code> <code>bool | str</code> <p>If set, include the <code>typer.Context</code> as the first argument to the function. If the value is not              boolean, use the passed string as the name of the context arg.</p> <code>False</code> <p>The following two command definitions are equivalent:</p> <pre><code>cli = typer.Typer()\n\n@cli.command()\n@simple_decorator\n@complex_decorator(\"nitro\", glycerine=True)\ndef static(\n    t_ctx: Typer.Context,\n    mite1: Annotated[str, typer.Argument(help=\"This is mighty argument 1\")],\n    dyna2: Annotated[int, typer.Option(help=\"This is dynamic option 2\")],\n    dyna1: Annotated[str, typer.Option(help=\"This is dynamic option 1\")] = \"default1\",\n    mite2: Annotated[int | None, typer.Argument(help=\"This is mighty argument 2\")] = None,\n):\n    '''\n    Just prints values of passed params\n    '''\n    print(f\"{dyna1=}, {dyna2=}, {mite1=}, {mite2=}\")\n\n\ndef dynamic(dyna1: str, dyna2: int, mite1: str, mite2: int | None):\n    '''\n    Just prints values of passed params\n    '''\n    print(f\"{dyna1=}, {dyna2=}, {mite1=}, {mite2=}\")\n\n\nbuild_command(\n    cli,\n    dynamic,\n    OptDef(name=\"dyna1\", param_type=str, help=\"This is dynamic option 1\", default=\"default1\"),\n    OptDef(name=\"dyna2\", param_type=int, help=\"This is dynamic option 2\"),\n    ArgDef(name=\"mite1\", param_type=str, help=\"This is mighty argument 1\"),\n    ArgDef(name=\"mite2\", param_type=int | None, help=\"This is mighty argument 2\", default=None),\n    decorators=[\n        DecDef(simple_decorator),\n        DecDef(complex_decorator, dec_args=[\"nitro\"], dec_kwargs=dict(glycerine=True)),\n    ],\n    include_context=\"t_ctx\",\n)\n</code></pre>"}]}